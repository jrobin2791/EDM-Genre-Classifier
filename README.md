# EDM-Genre-Classifier
Accurately predicting the genre of a song based on its audio features.


## Problem Statement
 
There a many different types and styles of music out there, which is why we have created a system of categorizing music by genres and subgenres. Genres help us to understand how music evolves and forms trends, and also helps listeners identify what they like to listen to. When it comes to the more well-known genres, most people are easily able to tell the difference between them. Some of the more obscure subgenres however, have differences that are more nuanced are difficult for most people to recognize. For example, recognizing the differences between rock music and classical music is much easier than distinguishing alternative rock from punk rock. Still, we know that human beings are capable of identifying the genre of the music the hear. The more people listen to different styles of music, the more they learn about what makes these styles unique, and the better they become at making these distinctions. In theory, a machine learning algorithm could learn about these differences as well. What I would like to explore in this project is how well a computer would be able to accurately predict the genre of a song.

To test this, I chose four major subgenres of electronic dance music, also known as EDM. While there are more than four genres of EDM, four of the biggest are dubstep, house, trance, and drum & bass. Being that these genres are all still electronic music, they might sound fairly similar to most people. However, fans of this type of music or people involved in the electronic music industry would most likely be able to tell the difference. I wanted the genres to be fairly similar becuase if a computer can tell the difference between trance and house, it can probably tell the difference between less similar genres just as well, if not better.

---

## Spotipy and the Spotify API

Spotify's API allows access to data on millions of songs, virtually anything you can think of, and also enables you to interact with your local Spotify device. In order to interface with the API, I will be using a Python library called Spotipy. Supported and developed by Spotify, Spotipy provides a great way to efficiently access data on millions of songs, including audio features such as the key, tempo, duration, loudness, and danceability. These audio features can be used to train a genre classification model.

---

## Executive Summary

The purpose of my application is to allow a user to search any song or artist and to play back songs that are similar. The songs can either be played one at a time in a channel format, or added to a playlist and saved in your profile. In addition, the user is
given the option to further personalize the recommendations. They can choose whether they would like to play the original reference song first or skip straight to recommendations. They also can elect to force the recommender to only play an artist once in the queue if this is desired. This is a particularly useful feature for those listeners who are interested in discovery, and provides an option not offered by Spotify. Users can also customize their recommendations with this app based on a popularity range. Spotify ranks every song in its bank by popularity from 0 to 100. If a user wanted to, for example, discover songs that they may not have heard before, they could for example, set the range to only play songs with a popularity between 0 and 25. Or if they wanted to hear only the most popular songs, they could control that as well. Another option users have is to set three possible levels of broadness in the results. This means that if you wanted the songs to be as similar to your song choice as possible, you could set the broadness to narrow. Or if you wanted to allow more flexibility and variety in the results, you could set the broadness to wide.

The system in place for this application involves pulling a list of recommendations from Spotify's API, filtering based on custom options, and then using a model to assess cosine similarity based on the audio features, genres, and popularity of the songs. The data builds on itself every time a new song is put into the queue, and this process can be repeated for as long as the user desires. It also has the ability to automatically play the results on Spotify and to make playlists out of these results. For music lovers, this is a very powerful tool which caters to specific listening preferences and makes it easy to create custom playlists in a streamlined fashion.

---

## Conclusion and Recommendations

Based on testing the results in many different areas of music, I found that the app does a very good job at making recommendations in a way that reasonably follows what is to be expected. The biggest limiting factor in this project is the fact that the original recommendations that are running through the model is limited by what Spotify gives you, however they do a very good job already. This just takes it a step further and allows for more personalization. The broadness settings do make a difference in the results, although the effectiveness of this varies depending on the area of music you are in. If I had a way to access Spotify's entire library of music at once, I would be able to take this recommender to the next level, but for now this is a very effective tool as it is, particularly when it comes to making playlists. In the future, I would like to test more possibilities and see where there could be improvement, and also make this into a web application that could be used by others.


I built a machine learning model that accurately predicts the genre of a song based on its audio features. The data was collected using Spotify's API and the spotipy python library. Audio features for 4000 songs were obtained from Spotify's recommendation system, 1000 from each of four different genres of electronic music. The four genres were dubstep, house, trance, and drum & bass. In addition, 25 songs from each of these four genres were handpicked to serve as a validation set. Once I had the data, I explored the distributions of each audio feature among the different genres using Seaborn visualizations to determine which features would be the most consequential in modeling. Most of the features were not useful, with the exception of tempo, duration, loudness, energy, and danceablility. These were the variables I chose to use for my models. Several outliers such as extended mixes and transition tracks that would not traditionally be considered as songs were removed. The data was further cleaned and processed in several other ways, including adjusting tempos where it was necessary, creating interaction columns and scaling variables. A variety of different classification models were attempted, including Random Forest, AdaBoost, Gradient Boost, and XGBoost. After tuning these models with randomized searching and grid searching over hyperparameters, I was able to predict the correct genre for 93% of the validation set. The best result came from a Voting Classifier ensemble between a Bagging Classifier, Gradient Boosting Classier, and XGBoost Classifier.